function test_buyer_profile()
%TEST_BUYER_PROFILE Validate buyer profile calculations against the Excel workbook.

validation_dir = fileparts(mfilename('fullpath'));
model_root = fileparts(validation_dir);
repo_root = fileparts(model_root);
excel_path = fullfile(repo_root, 'Tribe_model_20.1.26.xlsx');

addpath(model_root);

inputs = readInputs(excel_path);

rp = tribe.calc.calcRackProfile(inputs.chipset, inputs.cooling_method, ...
    inputs.module_it_target, inputs.electricity_price, inputs.annual_hours);
ref = tribe.data.ReferenceData();
mc = tribe.calc.calcModuleCriteria(rp, inputs.hp_enabled, inputs.hp_output_temp, ...
    inputs.utilisation, inputs.hours_per_year, inputs.base_heat_price, inputs.premium_heat_price);
mflow = tribe.calc.calcModuleFlow(mc, rp.cooling_method, ref);

bp = tribe.calc.calcBuyerProfile(rp, mc, mflow, inputs.process_id, ref);

expected = calcExpected(rp, mc, mflow, inputs, ref);
[excel_bp, has_bp] = readExcelExpectedBuyerProfile(excel_path);
if has_bp
    expected = mergeExpected(expected, excel_bp);
else
    fprintf('Buyer profile validation: Excel formulas not cached; using computed expectations.\n');
end

fields = [ ...
    "chipset", ...
    "cooling_method", ...
    "gpus_per_module", ...
    "module_it_capacity_kw", ...
    "select_process", ...
    "process_name", ...
    "size_category", ...
    "required_temperature_c", ...
    "heat_demand_kwth", ...
    "operating_hours_per_year", ...
    "notes", ...
    "source", ...
    "source_url", ...
    "annual_heat_demand_mwh", ...
    "process_deltat_c", ...
    "required_flow_rate_m3_per_hr", ...
    "module_thermal_capacity_kwth", ...
    "module_delivery_temp_c", ...
    "module_flow_capacity_m3_per_hr", ...
    "temperature_compatible", ...
    "modules_needed_thermal", ...
    "modules_if_flow_constrained_reference", ...
    "modules_required", ...
    "flow_deficit_m3_per_hr", ...
    "flow_ratio_buyer_per_system", ...
    "system_thermal_capacity_kwth", ...
    "system_flow_capacity_m3_per_hr", ...
    "thermal_utilisation_pct", ...
    "flow_utilisation_pct", ...
    "hydraulic_augmentation_needed", ...
    "system_heat_generation_kwth", ...
    "buyer_heat_absorption_kwth", ...
    "excess_heat_kwth", ...
    "excess_heat_pct", ...
    "heat_rejection_required", ...
    "rejection_method", ...
    "rejection_capacity_required_kwth", ...
    "rejection_capex_rate_gbp_per_kwth", ...
    "rejection_opex_rate_gbp_per_kwth_per_yr", ...
    "rejection_capex_gbp", ...
    "annual_rejection_opex_gbp_per_yr", ...
    "total_modules_required", ...
    "total_it_capacity_kw", ...
    "total_rack_units_42u_racks_10kw", ...
    "heat_pump_required", ...
    "temperature_lift_required_k", ...
    "heat_pump_units", ...
    "total_hp_capacity_kwth", ...
    "hp_electrical_demand_kw", ...
    "source_loop_pumps", ...
    "sink_loop_pumps", ...
    "total_system_flow_m3_per_hr", ...
    "header_pipe_size_estimate_dn", ...
    "buffer_tank_recommended", ...
    "flow_augmentation_pump_m3_per_hr", ...
    "mixing_valve_required", ...
    "augmentation_pump_power_kw", ...
    "augmentation_pumps_required", ...
    "augmentation_pump_capacity_m3_per_hr", ...
    "augmented_system_flow_m3_per_hr", ...
    "flow_requirement_met", ...
    "it_load_kw", ...
    "cooling_infrastructure_kw", ...
    "heat_pump_load_kw", ...
    "total_electrical_demand_kw", ...
    "grid_connection_kva_0_9_pf", ...
    "module_footprint_each_m", ...
    "total_module_footprint_m", ...
    "plant_room_allowance_m", ...
    "total_site_area_m", ...
    "modular_dc_units_250kw_it", ...
    "heat_pump_units__b108", ...
    "server_racks_42u", ...
    "source_circulation_pumps", ...
    "sink_circulation_pumps", ...
    "plate_heat_exchangers", ...
    "buffer_tank", ...
    "bms_per_controls_package", ...
    "flow_augmentation_pumps", ...
    "mixing_valves" ...
    ];

all_pass = true;
for i = 1:numel(fields)
    field = fields(i);
    all_pass = checkEqual("bp." + field, bp.(field), expected.(field)) && all_pass;
end

all_pass = runAlternateTests(all_pass, rp, mc, mflow, ref, inputs, fields);

if all_pass
    fprintf('Buyer profile validation: PASS\n');
else
    fprintf('Buyer profile validation: FAIL\n');
end
end

function inputs = readInputs(excel_path)
inputs = struct();

rp_data = readExcelRange(excel_path, '0. Rack Profile', 'B6:B70');
get_rp = @(row) rp_data{row - 5, 1};
inputs.chipset = get_rp(6);
inputs.cooling_method = get_rp(17);
inputs.module_it_target = get_rp(36);
inputs.electricity_price = get_rp(58);
inputs.annual_hours = get_rp(67);

mc_data = readExcelRange(excel_path, '1. Module Criteria', 'B6:B30');
get_mc = @(row) mc_data{row - 6 + 1, 1};
inputs.utilisation = get_mc(7);
inputs.hp_enabled = get_mc(15);
inputs.hp_output_temp = get_mc(16);
inputs.hours_per_year = get_mc(23);
inputs.base_heat_price = get_mc(27);
inputs.premium_heat_price = get_mc(28);

bp_data = readExcelRange(excel_path, '5. Buyer Profile', 'B11:B114');
get_bp = @(row) bp_data{row - 11 + 1, 1};
inputs.process_id = get_bp(11);
inputs.module_footprint_each_m = get_bp(100);
inputs.bms_per_controls_package = get_bp(114);
end

function expected = calcExpected(rp, mc, mflow, inputs, ref)
expected = struct();
expected.chipset = string(rp.chipset_type);
expected.cooling_method = string(rp.cooling_method);
expected.gpus_per_module = rp.gpus_per_module;
expected.module_it_capacity_kw = rp.actual_module_it_capacity_kw;
expected.select_process = string(inputs.process_id);

process = defaultProcess();
if ~isempty(inputs.process_id)
    try
        process = tribe.data.ProcessLibrary.getProcess(inputs.process_id);
    catch
        process = defaultProcess();
    end
end

expected.process_name = string(process.name);
expected.size_category = string(process.size_category);
expected.required_temperature_c = process.required_temp_c;
expected.heat_demand_kwth = process.heat_demand_kwth;
expected.operating_hours_per_year = process.operating_hours_per_year;
expected.notes = string(process.notes);
expected.source = string(process.source);
expected.source_url = string(process.source_url);

expected.annual_heat_demand_mwh = expected.heat_demand_kwth * expected.operating_hours_per_year / 1000;
expected.process_deltat_c = process.delta_t_c;
expected.required_flow_rate_m3_per_hr = expected.heat_demand_kwth ...
    / (4.18 * expected.process_deltat_c) * 3.6;

expected.module_thermal_capacity_kwth = mc.thermal_output_kwth;
expected.module_delivery_temp_c = mc.delivery_temperature_c;
expected.module_flow_capacity_m3_per_hr = mflow.volume_flow_rate_m3_per_hr__b26;

if expected.module_delivery_temp_c >= expected.required_temperature_c
    expected.temperature_compatible = "YES";
else
    expected.temperature_compatible = "NO - need higher temp";
end

expected.modules_needed_thermal = roundup(expected.heat_demand_kwth ...
    / expected.module_thermal_capacity_kwth, 0);
expected.modules_if_flow_constrained_reference = roundup(expected.required_flow_rate_m3_per_hr ...
    / expected.module_flow_capacity_m3_per_hr, 0);
expected.modules_required = expected.modules_needed_thermal;

expected.flow_deficit_m3_per_hr = max(0, expected.required_flow_rate_m3_per_hr ...
    - expected.modules_required * expected.module_flow_capacity_m3_per_hr);

denom_flow = expected.modules_required * expected.module_flow_capacity_m3_per_hr;
if denom_flow > 0
    expected.flow_ratio_buyer_per_system = expected.required_flow_rate_m3_per_hr / denom_flow;
else
    expected.flow_ratio_buyer_per_system = 0;
end

expected.system_thermal_capacity_kwth = expected.modules_required * expected.module_thermal_capacity_kwth;
expected.system_flow_capacity_m3_per_hr = expected.modules_required * expected.module_flow_capacity_m3_per_hr;
expected.thermal_utilisation_pct = expected.heat_demand_kwth / expected.system_thermal_capacity_kwth;

expected.flow_augmentation_pump_m3_per_hr = expected.flow_deficit_m3_per_hr;
if expected.flow_deficit_m3_per_hr > 0
    expected.mixing_valve_required = "YES";
else
    expected.mixing_valve_required = "NO";
end

if expected.flow_deficit_m3_per_hr > 0
    expected.augmentation_pumps_required = roundup(expected.flow_deficit_m3_per_hr ...
        / ref.standard_augmentation_pump_capacity_m3_per_hr, 0);
else
    expected.augmentation_pumps_required = 0;
end

expected.augmentation_pump_capacity_m3_per_hr = expected.augmentation_pumps_required ...
    * ref.standard_augmentation_pump_capacity_m3_per_hr;
expected.augmentation_pump_power_kw = expected.augmentation_pump_capacity_m3_per_hr ...
    * ref.augmentation_pump_power_kw_per_m3_per_hr;
expected.augmented_system_flow_m3_per_hr = expected.system_flow_capacity_m3_per_hr ...
    + expected.augmentation_pump_capacity_m3_per_hr;

if expected.augmented_system_flow_m3_per_hr > 0
    expected.flow_utilisation_pct = expected.required_flow_rate_m3_per_hr ...
        / expected.augmented_system_flow_m3_per_hr;
else
    expected.flow_utilisation_pct = expected.required_flow_rate_m3_per_hr ...
        / expected.system_flow_capacity_m3_per_hr;
end

if expected.flow_ratio_buyer_per_system > 1
    expected.hydraulic_augmentation_needed = "YES - flow ratio " ...
        + string(round(expected.flow_ratio_buyer_per_system, 2)) + "x";
else
    expected.hydraulic_augmentation_needed = "NO";
end

expected.system_heat_generation_kwth = expected.system_thermal_capacity_kwth;
expected.buyer_heat_absorption_kwth = min(expected.heat_demand_kwth, expected.system_thermal_capacity_kwth);
expected.excess_heat_kwth = max(0, expected.system_heat_generation_kwth - expected.buyer_heat_absorption_kwth);
if expected.system_heat_generation_kwth > 0
    expected.excess_heat_pct = expected.excess_heat_kwth / expected.system_heat_generation_kwth;
else
    expected.excess_heat_pct = 0;
end

if expected.excess_heat_kwth > 0
    expected.heat_rejection_required = "YES - " + string(round(expected.excess_heat_kwth, 0)) ...
        + " kWth rejection needed";
else
    expected.heat_rejection_required = "NO - full utilisation";
end

if expected.excess_heat_kwth == 0
    expected.rejection_method = "-";
elseif expected.excess_heat_kwth < ref.dry_cooler_max_kwth
    expected.rejection_method = "Dry cooler";
elseif expected.excess_heat_kwth < ref.adiabatic_cooler_max_kwth
    expected.rejection_method = "Adiabatic cooler";
else
    expected.rejection_method = "Cooling tower";
end

expected.rejection_capacity_required_kwth = expected.excess_heat_kwth;
if expected.rejection_method == "-"
    expected.rejection_capex_rate_gbp_per_kwth = 0;
    expected.rejection_opex_rate_gbp_per_kwth_per_yr = 0;
elseif expected.rejection_method == "Dry cooler"
    expected.rejection_capex_rate_gbp_per_kwth = ref.dry_cooler__capex_gbp_per_kwth;
    expected.rejection_opex_rate_gbp_per_kwth_per_yr = ref.dry_cooler__opex_gbp_per_kwth_per_yr;
elseif expected.rejection_method == "Adiabatic cooler"
    expected.rejection_capex_rate_gbp_per_kwth = ref.adiabatic_cooler__capex_gbp_per_kwth;
    expected.rejection_opex_rate_gbp_per_kwth_per_yr = ref.adiabatic_cooler__opex_gbp_per_kwth_per_yr;
else
    expected.rejection_capex_rate_gbp_per_kwth = ref.cooling_tower__capex_gbp_per_kwth;
    expected.rejection_opex_rate_gbp_per_kwth_per_yr = ref.cooling_tower__opex_gbp_per_kwth_per_yr;
end

expected.rejection_capex_gbp = expected.rejection_capacity_required_kwth ...
    * expected.rejection_capex_rate_gbp_per_kwth;
expected.annual_rejection_opex_gbp_per_yr = expected.rejection_capacity_required_kwth ...
    * expected.rejection_opex_rate_gbp_per_kwth_per_yr;

expected.total_modules_required = expected.modules_required;
expected.total_it_capacity_kw = expected.modules_required * mc.module_it_capacity_kw;
expected.total_rack_units_42u_racks_10kw = roundup(expected.total_it_capacity_kw / 10, 0);

if expected.required_temperature_c > mc.capture_temperature_c
    expected.heat_pump_required = "YES";
    expected.temperature_lift_required_k = expected.required_temperature_c - mc.capture_temperature_c;
else
    expected.heat_pump_required = "NO - direct heat sufficient";
    expected.temperature_lift_required_k = 0;
end

expected.heat_pump_units = expected.modules_required;
expected.total_hp_capacity_kwth = expected.modules_required * mc.heat_pump_capacity_kwth;

if ~isnumber(mc.heat_pump_cop) || mc.heat_pump_cop <= 1
    expected.hp_electrical_demand_kw = 0;
else
    expected.hp_electrical_demand_kw = expected.system_thermal_capacity_kwth / mc.heat_pump_cop;
end

expected.source_loop_pumps = expected.modules_required;
expected.sink_loop_pumps = expected.modules_required;
expected.total_system_flow_m3_per_hr = expected.system_flow_capacity_m3_per_hr;

if expected.system_flow_capacity_m3_per_hr < 10
    expected.header_pipe_size_estimate_dn = "DN50";
elseif expected.system_flow_capacity_m3_per_hr < 25
    expected.header_pipe_size_estimate_dn = "DN65";
elseif expected.system_flow_capacity_m3_per_hr < 50
    expected.header_pipe_size_estimate_dn = "DN80";
elseif expected.system_flow_capacity_m3_per_hr < 100
    expected.header_pipe_size_estimate_dn = "DN100";
else
    expected.header_pipe_size_estimate_dn = "DN125+";
end

if expected.modules_required > 2
    expected.buffer_tank_recommended = "YES - system balancing";
else
    expected.buffer_tank_recommended = "OPTIONAL";
end

flow_shortfall_m3_per_hr = expected.required_flow_rate_m3_per_hr - expected.augmented_system_flow_m3_per_hr;
m3_symbol = char(179);
if expected.augmented_system_flow_m3_per_hr >= expected.required_flow_rate_m3_per_hr
    expected.flow_requirement_met = "YES";
else
    expected.flow_requirement_met = "NO - shortfall of " + string(round(flow_shortfall_m3_per_hr, 1)) ...
        + " m" + string(m3_symbol) + "/hr";
end

expected.it_load_kw = expected.total_it_capacity_kw;
expected.cooling_infrastructure_kw = expected.total_it_capacity_kw * mc.target_utilisation_rate_pct * 0.05;
expected.heat_pump_load_kw = expected.hp_electrical_demand_kw;
expected.total_electrical_demand_kw = expected.it_load_kw + expected.cooling_infrastructure_kw ...
    + expected.heat_pump_load_kw;
expected.grid_connection_kva_0_9_pf = roundup(expected.total_electrical_demand_kw / 0.9, -1);

expected.module_footprint_each_m = inputs.module_footprint_each_m;
expected.total_module_footprint_m = expected.modules_required * expected.module_footprint_each_m;
if expected.modules_required > 2
    expected.plant_room_allowance_m = 25;
else
    expected.plant_room_allowance_m = 15;
end
expected.total_site_area_m = expected.total_module_footprint_m + expected.plant_room_allowance_m;

expected.modular_dc_units_250kw_it = expected.modules_required;
expected.heat_pump_units__b108 = expected.heat_pump_units;
expected.server_racks_42u = expected.total_rack_units_42u_racks_10kw;
expected.source_circulation_pumps = expected.source_loop_pumps;
expected.sink_circulation_pumps = expected.sink_loop_pumps;
expected.plate_heat_exchangers = expected.modules_required;
if expected.buffer_tank_recommended == "YES - system balancing"
    expected.buffer_tank = 1;
else
    expected.buffer_tank = 0;
end
expected.bms_per_controls_package = inputs.bms_per_controls_package;
expected.flow_augmentation_pumps = expected.augmentation_pumps_required;
if expected.augmentation_pumps_required > 0
    expected.mixing_valves = 1;
else
    expected.mixing_valves = 0;
end
end

function [expected, has_excel_values] = readExcelExpectedBuyerProfile(excel_path)
data = readExcelRange(excel_path, '5. Buyer Profile', 'B5:B116');
get_cell = @(row) data{row - 5 + 1, 1};

sentinel_rows = [24, 34, 41, 53, 75, 97, 103];
has_excel_values = hasValues(get_cell, sentinel_rows);

mapping = { ...
    'chipset', 5, 1; ...
    'cooling_method', 6, 1; ...
    'gpus_per_module', 7, 1; ...
    'module_it_capacity_kw', 8, 1; ...
    'select_process', 11, 1; ...
    'process_name', 14, 1; ...
    'size_category', 15, 1; ...
    'required_temperature_c', 16, 1; ...
    'heat_demand_kwth', 17, 1; ...
    'operating_hours_per_year', 18, 1; ...
    'notes', 19, 1; ...
    'source', 20, 1; ...
    'source_url', 21, 1; ...
    'annual_heat_demand_mwh', 24, 1; ...
    'process_deltat_c', 25, 1; ...
    'required_flow_rate_m3_per_hr', 26, 1; ...
    'module_thermal_capacity_kwth', 29, 1; ...
    'module_delivery_temp_c', 30, 1; ...
    'module_flow_capacity_m3_per_hr', 31, 1; ...
    'temperature_compatible', 33, 1; ...
    'modules_needed_thermal', 34, 1; ...
    'modules_if_flow_constrained_reference', 35, 1; ...
    'modules_required', 36, 1; ...
    'flow_deficit_m3_per_hr', 37, 1; ...
    'flow_ratio_buyer_per_system', 38, 1; ...
    'system_thermal_capacity_kwth', 41, 1; ...
    'system_flow_capacity_m3_per_hr', 42, 1; ...
    'thermal_utilisation_pct', 43, 1; ...
    'flow_utilisation_pct', 44, 1; ...
    'hydraulic_augmentation_needed', 45, 1; ...
    'system_heat_generation_kwth', 48, 1; ...
    'buyer_heat_absorption_kwth', 49, 1; ...
    'excess_heat_kwth', 50, 1; ...
    'excess_heat_pct', 51, 1; ...
    'heat_rejection_required', 52, 1; ...
    'rejection_method', 53, 1; ...
    'rejection_capacity_required_kwth', 54, 1; ...
    'rejection_capex_rate_gbp_per_kwth', 55, 1; ...
    'rejection_opex_rate_gbp_per_kwth_per_yr', 56, 1; ...
    'rejection_capex_gbp', 57, 1; ...
    'annual_rejection_opex_gbp_per_yr', 58, 1; ...
    'total_modules_required', 66, 1; ...
    'total_it_capacity_kw', 67, 1; ...
    'total_rack_units_42u_racks_10kw', 68, 1; ...
    'heat_pump_required', 71, 1; ...
    'temperature_lift_required_k', 72, 1; ...
    'heat_pump_units', 73, 1; ...
    'total_hp_capacity_kwth', 74, 1; ...
    'hp_electrical_demand_kw', 75, 1; ...
    'source_loop_pumps', 78, 1; ...
    'sink_loop_pumps', 79, 1; ...
    'total_system_flow_m3_per_hr', 80, 1; ...
    'header_pipe_size_estimate_dn', 81, 1; ...
    'buffer_tank_recommended', 82, 1; ...
    'flow_augmentation_pump_m3_per_hr', 83, 1; ...
    'mixing_valve_required', 84, 1; ...
    'augmentation_pump_power_kw', 85, 1; ...
    'augmentation_pumps_required', 86, 1; ...
    'augmentation_pump_capacity_m3_per_hr', 87, 1; ...
    'augmented_system_flow_m3_per_hr', 88, 1; ...
    'flow_requirement_met', 89, 1; ...
    'it_load_kw', 93, 1; ...
    'cooling_infrastructure_kw', 94, 1; ...
    'heat_pump_load_kw', 95, 1; ...
    'total_electrical_demand_kw', 96, 1; ...
    'grid_connection_kva_0_9_pf', 97, 1; ...
    'module_footprint_each_m', 100, 1; ...
    'total_module_footprint_m', 101, 1; ...
    'plant_room_allowance_m', 102, 1; ...
    'total_site_area_m', 103, 1; ...
    'modular_dc_units_250kw_it', 107, 1; ...
    'heat_pump_units__b108', 108, 1; ...
    'server_racks_42u', 109, 1; ...
    'source_circulation_pumps', 110, 1; ...
    'sink_circulation_pumps', 111, 1; ...
    'plate_heat_exchangers', 112, 1; ...
    'buffer_tank', 113, 1; ...
    'bms_per_controls_package', 114, 1; ...
    'flow_augmentation_pumps', 115, 1; ...
    'mixing_valves', 116, 1 ...
    };

expected = readMappedCells(data, 5, mapping);
end

function ok = runAlternateTests(all_pass, rp, mc, mflow, ref, inputs, fields)
alt_processes = [ ...
    "Swimming pool - Large", ...
    "District heating - Large", ...
    "Commercial laundry - Medium" ...
    ];

for i = 1:numel(alt_processes)
    alt_inputs = inputs;
    alt_inputs.process_id = alt_processes(i);
    bp = tribe.calc.calcBuyerProfile(rp, mc, mflow, alt_processes(i), ref);
    expected = calcExpected(rp, mc, mflow, alt_inputs, ref);
    for j = 1:numel(fields)
        field = fields(j);
        all_pass = checkEqual("alt." + string(i) + "." + field, ...
            bp.(field), expected.(field)) && all_pass;
    end
end

ok = all_pass;
end

function expected = readMappedCells(data, start_row, mapping)
expected = struct();
for i = 1:size(mapping, 1)
    field = mapping{i, 1};
    row = mapping{i, 2};
    col = mapping{i, 3};
    value = data{row - start_row + 1, col};
    if isFormulaValue(value) || ismissingValue(value)
        continue;
    end
    expected.(field) = value;
end
end

function tf = hasValues(get_cell, rows)
tf = false;
for i = 1:numel(rows)
    value = get_cell(rows(i));
    if isFormulaValue(value) || ismissingValue(value)
        continue;
    end
    if isnumeric(value)
        if any(~isnan(value), 'all') && any(abs(value) > 0, 'all')
            tf = true;
            return;
        end
    elseif (isstring(value) || ischar(value)) && strlength(string(value)) > 0
        tf = true;
        return;
    end
end
end

function ok = checkEqual(label, expected, actual)
if isstring(expected) || ischar(expected)
    ok = isequal(string(expected), string(actual));
elseif isnumeric(expected)
    ok = isnumeric(actual) && isequal(size(expected), size(actual)) ...
        && all(abs(expected - actual) < 1e-9, 'all');
else
    ok = isequaln(expected, actual);
end

if ok
    fprintf('PASS: %s\n', label);
else
    fprintf('FAIL: %s | expected: %s | actual: %s\n', label, valueToString(expected), valueToString(actual));
end
end

function data = readExcelRange(excel_path, sheet, range)
try
    data = readcell(excel_path, 'Sheet', sheet, 'Range', range, 'UseExcel', true);
catch
    data = readcell(excel_path, 'Sheet', sheet, 'Range', range);
end
end

function tf = isFormulaValue(value)
tf = (ischar(value) || isstring(value)) && startsWith(string(value), "=");
end

function tf = ismissingValue(value)
tf = isempty(value) ...
    || (isstring(value) && all(ismissing(value))) ...
    || (isnumeric(value) && any(isnan(value), 'all'));
end

function process = defaultProcess()
process = struct( ...
    'name', "-", ...
    'size_category', "-", ...
    'required_temp_c', 0, ...
    'heat_demand_kwth', 0, ...
    'operating_hours_per_year', 0, ...
    'notes', "-", ...
    'source', "", ...
    'delta_t_c', 10, ...
    'source_url', "" ...
);
end

function tf = isnumber(value)
tf = isnumeric(value) && isscalar(value) && ~isnan(value);
end

function y = roundup(x, digits)
if nargin < 2
    digits = 0;
end
factor = 10.^digits;
y = sign(x) .* ceil(abs(x) .* factor) ./ factor;
end

function text = valueToString(value)
if isstring(value) || ischar(value)
    text = char(string(value));
elseif isnumeric(value)
    text = mat2str(value);
else
    text = '<unprintable>';
end
end

function expected = mergeExpected(expected, excel_expected)
fields = fieldnames(excel_expected);
for i = 1:numel(fields)
    field = fields{i};
    expected.(field) = excel_expected.(field);
end
end
