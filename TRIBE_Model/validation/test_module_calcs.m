function test_module_calcs()
%TEST_MODULE_CALCS Validate module calculations against the Excel workbook.

validation_dir = fileparts(mfilename('fullpath'));
model_root = fileparts(validation_dir);
repo_root = fileparts(model_root);
excel_path = fullfile(repo_root, 'Tribe_model_20.1.26.xlsx');

addpath(model_root);

inputs = readInputs(excel_path);
rp = tribe.calc.calcRackProfile(inputs.chipset, inputs.cooling_method, ...
    inputs.module_it_target, inputs.electricity_price, inputs.annual_hours);

ref = tribe.data.ReferenceData();
mc = tribe.calc.calcModuleCriteria(rp, inputs.hp_enabled, inputs.hp_output_temp, ...
    inputs.utilisation, inputs.hours_per_year, inputs.base_heat_price, inputs.premium_heat_price);
mcapex = tribe.calc.calcModuleCapex(rp, mc, ref);
mopex = tribe.calc.calcModuleOpex(rp, mc, mcapex, inputs.electricity_rate);
mflow = tribe.calc.calcModuleFlow(mc, rp.cooling_method, ref);

expected = calcExpected(rp, inputs, ref);

[excel_mc, has_mc] = readExcelExpectedModuleCriteria(excel_path);
[excel_mcapex, has_mcapex] = readExcelExpectedModuleCapex(excel_path);
[excel_mopex, has_mopex] = readExcelExpectedModuleOpex(excel_path);
[excel_mflow, has_mflow] = readExcelExpectedModuleFlow(excel_path);

if has_mc
    expected.mc = mergeExpected(expected.mc, excel_mc);
else
    fprintf('Module criteria validation: Excel formulas not cached; using computed expectations.\n');
end

if has_mcapex
    expected.mcapex = mergeExpected(expected.mcapex, excel_mcapex);
else
    fprintf('Module capex validation: Excel formulas not cached; using computed expectations.\n');
end

if has_mopex
    expected.mopex = mergeExpected(expected.mopex, excel_mopex);
else
    fprintf('Module opex validation: Excel formulas not cached; using computed expectations.\n');
end

if has_mflow
    expected.mflow = mergeExpected(expected.mflow, excel_mflow);
else
    fprintf('Module flow validation: Excel formulas not cached; using computed expectations.\n');
end

all_pass = true;

mc_fields = [ ...
    "module_it_capacity_kw", ...
    "compute_rate_gbp_per_kw_per_month", ...
    "target_utilisation_rate_pct", ...
    "heat_capture_rate_pct", ...
    "captured_heat_kwth", ...
    "capture_temperature_c", ...
    "heat_pump_enabled", ...
    "heat_pump_output_temperature_c", ...
    "heat_pump_cop", ...
    "heat_pump_capacity_kwth", ...
    "thermal_output_kwth", ...
    "delivery_temperature_c", ...
    "hours_per_year", ...
    "annual_heat_output_mwh", ...
    "base_heat_price_no_hp_gbp_per_mwh", ...
    "premium_heat_price_with_hp_gbp_per_mwh", ...
    "effective_heat_price_gbp_per_mwh", ...
    "reference_industrial_gas_price_gbp_per_mwh" ...
    ];

mcapex_fields = [ ...
    "chipset", ...
    "cooling_method", ...
    "racks_per_module", ...
    "servers_per_module", ...
    "module_it_capacity_kw", ...
    "captured_heat_kwth", ...
    "container_shell", ...
    "container_fit_out", ...
    "rack_enclosures", ...
    "rack_enclosures__fixed_per_module", ...
    "subtotal_enclosure", ...
    "cold_plate_kits", ...
    "cdu_base", ...
    "cdu_capacity_scaling", ...
    "manifolds_quick_connects", ...
    "primary_loop_piping", ...
    "subtotal_dtc_cooling", ...
    "immersion_tanks", ...
    "dielectric_fluid_initial_fill", ...
    "fluid_management_system", ...
    "subtotal_immersion_cooling", ...
    "rack_pdus", ...
    "module_power_distribution", ...
    "electrical_panels_switchgear", ...
    "subtotal_power", ...
    "primary_heat_exchanger_base", ...
    "heat_exchanger_capacity_scaling", ...
    "thermal_integration_skid", ...
    "instrumentation_sensors", ...
    "subtotal_thermal", ...
    "bms_base_system", ...
    "per_rack_monitoring", ...
    "network_infrastructure", ...
    "subtotal_monitoring", ...
    "heat_pump_capex_rate_gbp_per_kwth", ...
    "heat_pump_unit", ...
    "heat_pump_installation", ...
    "heat_pump_controls", ...
    "subtotal_heat_pump", ...
    "premium_rate_pct", ...
    "applied_to_base_infrastructure", ...
    "base_infrastructure", ...
    "cooling_premium", ...
    "heat_pump", ...
    "total_module_capex", ...
    "capex_per_it_kw_gbp_per_kw", ...
    "capex_per_gpu_gbp_per_gpu" ...
    ];

mopex_fields = [ ...
    "electricity_rate_gbp_per_kwh", ...
    "infrastructure_power_from_pue", ...
    "infrastructure_power_cost_gbp_per_yr", ...
    "heat_pump_electricity_gbp_per_yr", ...
    "subtotal_electricity", ...
    "base_maintenance_pct_of_base_capex", ...
    "base_maintenance_gbp_per_yr", ...
    "heat_pump_maintenance_pct_of_hp_capex", ...
    "heat_pump_maintenance_gbp_per_yr", ...
    "insurance_pct_of_total_capex", ...
    "insurance_gbp_per_yr", ...
    "subtotal_maintenance_insurance", ...
    "site_lease_per_licence_gbp_per_yr", ...
    "remote_monitoring_noc_gbp_per_yr", ...
    "connectivity_admin_gbp_per_yr", ...
    "subtotal_other", ...
    "total_module_opex_gbp_per_yr" ...
    ];

mflow_fields = [ ...
    "specific_heat_of_water_kj_per_kg_k", ...
    "water_density_kg_per_l", ...
    "thermal_power_kwth", ...
    "inlet_temperature_c", ...
    "source_loop_deltat_c", ...
    "outlet_temperature_c", ...
    "mass_flow_rate_kg_per_s", ...
    "volume_flow_rate_l_per_s", ...
    "volume_flow_rate_m3_per_hr", ...
    "thermal_power_delivered_kwth", ...
    "outlet_temperature_c__b20", ...
    "sink_loop_deltat_c", ...
    "return_temperature_c", ...
    "mass_flow_rate_kg_per_s__b24", ...
    "volume_flow_rate_l_per_s__b25", ...
    "volume_flow_rate_m3_per_hr__b26", ...
    "design_velocity_m_per_s", ...
    "source_loop_pipe_id_mm", ...
    "sink_loop_pipe_id_mm", ...
    "source_loop_nearest_dn", ...
    "sink_loop_nearest_dn", ...
    "thermal_capacity_kwth", ...
    "delivery_temperature_c", ...
    "flow_capacity_m3_per_hr" ...
    ];

for i = 1:numel(mc_fields)
    field = mc_fields(i);
    all_pass = checkEqual("mc." + field, mc.(field), expected.mc.(field)) && all_pass;
end

for i = 1:numel(mcapex_fields)
    field = mcapex_fields(i);
    all_pass = checkEqual("mcapex." + field, mcapex.(field), expected.mcapex.(field)) && all_pass;
end

for i = 1:numel(mopex_fields)
    field = mopex_fields(i);
    all_pass = checkEqual("mopex." + field, mopex.(field), expected.mopex.(field)) && all_pass;
end

for i = 1:numel(mflow_fields)
    field = mflow_fields(i);
    all_pass = checkEqual("mflow." + field, mflow.(field), expected.mflow.(field)) && all_pass;
end

all_pass = runHeatPumpToggleTests(all_pass, inputs, rp, ref, mc_fields, mcapex_fields, mopex_fields, mflow_fields);

if all_pass
    fprintf('Module calculations validation: PASS\n');
else
    fprintf('Module calculations validation: FAIL\n');
end
end

function inputs = readInputs(excel_path)
inputs = struct();

rp_data = readExcelRange(excel_path, '0. Rack Profile', 'B6:B70');
get_rp = @(row) rp_data{row - 5, 1};
inputs.chipset = get_rp(6);
inputs.cooling_method = get_rp(17);
inputs.module_it_target = get_rp(36);
inputs.electricity_price = get_rp(58);
inputs.annual_hours = get_rp(67);

mc_data = readExcelRange(excel_path, '1. Module Criteria', 'B6:B30');
get_mc = @(row) mc_data{row - 6 + 1, 1};
inputs.compute_rate = get_mc(6);
inputs.utilisation = get_mc(7);
inputs.hp_enabled = get_mc(15);
inputs.hp_output_temp = get_mc(16);
inputs.hours_per_year = get_mc(23);
inputs.base_heat_price = get_mc(27);
inputs.premium_heat_price = get_mc(28);
inputs.reference_gas_price = get_mc(30);

mcapex_data = readExcelRange(excel_path, '2. Module Capex', 'B52:B52');
inputs.heat_pump_capex_rate = mcapex_data{1};

mopex_data = readExcelRange(excel_path, '3. Module Opex', 'B5:B29');
get_mopex = @(row) mopex_data{row - 5 + 1, 1};
inputs.electricity_rate = get_mopex(5);
inputs.base_maintenance_pct = get_mopex(15);
inputs.heat_pump_maintenance_pct = get_mopex(17);
inputs.insurance_pct = get_mopex(19);
inputs.site_lease = get_mopex(24);
inputs.remote_monitoring = get_mopex(25);
inputs.connectivity_admin = get_mopex(26);

mflow_data = readExcelRange(excel_path, '4. Module Flow', 'B5:B39');
get_mflow = @(row) mflow_data{row - 5 + 1, 1};
inputs.specific_heat = get_mflow(5);
inputs.water_density = get_mflow(6);
inputs.sink_loop_deltat = get_mflow(21);
inputs.design_velocity = get_mflow(29);
end

function expected = calcExpected(rp, inputs, ref)
expected = struct();
expected.mc = struct();
expected.mc.module_it_capacity_kw = rp.actual_module_it_capacity_kw;
expected.mc.compute_rate_gbp_per_kw_per_month = inputs.compute_rate;
expected.mc.target_utilisation_rate_pct = inputs.utilisation;
expected.mc.heat_capture_rate_pct = rp.heat_capture_rate_pct;
expected.mc.captured_heat_kwth = expected.mc.module_it_capacity_kw * expected.mc.heat_capture_rate_pct;
expected.mc.capture_temperature_c = rp.capture_temperature_c;
expected.mc.heat_pump_enabled = double(inputs.hp_enabled);
expected.mc.heat_pump_output_temperature_c = inputs.hp_output_temp;

if expected.mc.heat_pump_enabled == 0
    expected.mc.heat_pump_cop = "-";
else
    cop_raw = round(ref.carnot_efficiency_factor * (expected.mc.heat_pump_output_temperature_c + 273.15) ...
        / (expected.mc.heat_pump_output_temperature_c - expected.mc.capture_temperature_c), 2);
    expected.mc.heat_pump_cop = boundCop(cop_raw, ref);
end

expected.mc.heat_pump_capacity_kwth = expected.mc.captured_heat_kwth;

if expected.mc.heat_pump_enabled == 1
    if expected.mc.heat_pump_cop <= 1
        expected.mc.thermal_output_kwth = expected.mc.captured_heat_kwth;
    else
        expected.mc.thermal_output_kwth = expected.mc.captured_heat_kwth ...
            * expected.mc.heat_pump_cop / (expected.mc.heat_pump_cop - 1);
    end
else
    expected.mc.thermal_output_kwth = expected.mc.captured_heat_kwth;
end

if expected.mc.heat_pump_enabled == 1
    expected.mc.delivery_temperature_c = expected.mc.heat_pump_output_temperature_c;
else
    expected.mc.delivery_temperature_c = expected.mc.capture_temperature_c;
end

expected.mc.hours_per_year = inputs.hours_per_year;
expected.mc.annual_heat_output_mwh = expected.mc.thermal_output_kwth * expected.mc.hours_per_year ...
    * expected.mc.target_utilisation_rate_pct / 1000;
expected.mc.base_heat_price_no_hp_gbp_per_mwh = inputs.base_heat_price;
expected.mc.premium_heat_price_with_hp_gbp_per_mwh = inputs.premium_heat_price;
if expected.mc.heat_pump_enabled == 1
    expected.mc.effective_heat_price_gbp_per_mwh = expected.mc.premium_heat_price_with_hp_gbp_per_mwh;
else
    expected.mc.effective_heat_price_gbp_per_mwh = expected.mc.base_heat_price_no_hp_gbp_per_mwh;
end
expected.mc.reference_industrial_gas_price_gbp_per_mwh = inputs.reference_gas_price;

expected.mcapex = struct();
expected.mcapex.chipset = string(rp.chipset_type);
expected.mcapex.cooling_method = string(rp.cooling_method);
expected.mcapex.racks_per_module = rp.racks_per_module;
expected.mcapex.servers_per_module = rp.servers_per_module;
expected.mcapex.module_it_capacity_kw = rp.actual_module_it_capacity_kw;
expected.mcapex.captured_heat_kwth = rp.captured_heat_kwth;

expected.mcapex.container_shell = ref.container_shell_40ft;
expected.mcapex.container_fit_out = ref.container_fit_out_electrical_hvac_prep;
expected.mcapex.rack_enclosures = expected.mcapex.racks_per_module * ref.rack_enclosure_42u_enclosed;

pound = char(163);
times_symbol = char(215);
expected.mcapex.rack_enclosures__fixed_per_module = string(expected.mcapex.racks_per_module) ...
    + " racks " + times_symbol + " " + pound + string(ref.rack_enclosure_42u_enclosed);

expected.mcapex.subtotal_enclosure = sum([expected.mcapex.container_shell, ...
    expected.mcapex.container_fit_out, expected.mcapex.rack_enclosures]);

is_dtc = expected.mcapex.cooling_method == "Direct-to-Chip (DTC)";
expected.mcapex.cold_plate_kits = ifzero(is_dtc, expected.mcapex.servers_per_module * ref.cold_plate_kit_per_server);
expected.mcapex.cdu_base = ifzero(is_dtc, ref.cdu_coolant_distribution_unit);
expected.mcapex.cdu_capacity_scaling = ifzero(is_dtc, expected.mcapex.module_it_capacity_kw * ref.cdu_capacity_scaling);
expected.mcapex.manifolds_quick_connects = ifzero(is_dtc, expected.mcapex.servers_per_module * ref.manifolds_quick_connects);
expected.mcapex.primary_loop_piping = ifzero(is_dtc, ref.primary_loop_piping);
expected.mcapex.subtotal_dtc_cooling = sum([expected.mcapex.cold_plate_kits, expected.mcapex.cdu_base, ...
    expected.mcapex.cdu_capacity_scaling, expected.mcapex.manifolds_quick_connects, ...
    expected.mcapex.primary_loop_piping]);

is_single = expected.mcapex.cooling_method == "Single-Phase Immersion";
is_two = expected.mcapex.cooling_method == "Two-Phase Immersion";
expected.mcapex.immersion_tanks = ifzero(is_single, expected.mcapex.racks_per_module * ref.single_phase_immersion_tank) ...
    + ifzero(is_two, expected.mcapex.racks_per_module * ref.two_phase_immersion_tank);
expected.mcapex.dielectric_fluid_initial_fill = ifzero(is_single, expected.mcapex.racks_per_module ...
    * ref.fluid_volume_per_rack_single_phase * ref.dielectric_fluid_single_phase) ...
    + ifzero(is_two, expected.mcapex.racks_per_module ...
    * ref.fluid_volume_per_rack_two_phase * ref.dielectric_fluid_two_phase);
expected.mcapex.fluid_management_system = ifzero(is_single || is_two, ref.fluid_management_system);
expected.mcapex.subtotal_immersion_cooling = sum([expected.mcapex.immersion_tanks, ...
    expected.mcapex.dielectric_fluid_initial_fill, expected.mcapex.fluid_management_system]);

expected.mcapex.rack_pdus = expected.mcapex.racks_per_module * ref.high_density_pdu_per_rack;
expected.mcapex.module_power_distribution = expected.mcapex.module_it_capacity_kw * ref.module_power_distribution;
expected.mcapex.electrical_panels_switchgear = ref.electrical_panels_switchgear;
expected.mcapex.subtotal_power = sum([expected.mcapex.rack_pdus, expected.mcapex.module_power_distribution, ...
    expected.mcapex.electrical_panels_switchgear]);

expected.mcapex.primary_heat_exchanger_base = ref.primary_heat_exchanger;
expected.mcapex.heat_exchanger_capacity_scaling = expected.mcapex.captured_heat_kwth * ref.heat_exchanger_scaling;
expected.mcapex.thermal_integration_skid = ref.thermal_integration_skid_pumps_valves;
expected.mcapex.instrumentation_sensors = ref.instrumentation_sensors;
expected.mcapex.subtotal_thermal = sum([expected.mcapex.primary_heat_exchanger_base, ...
    expected.mcapex.heat_exchanger_capacity_scaling, expected.mcapex.thermal_integration_skid, ...
    expected.mcapex.instrumentation_sensors]);

expected.mcapex.bms_base_system = ref.bms_base_system;
expected.mcapex.per_rack_monitoring = expected.mcapex.racks_per_module * ref.per_rack_monitoring;
expected.mcapex.network_infrastructure = ref.network_infrastructure;
expected.mcapex.subtotal_monitoring = sum([expected.mcapex.bms_base_system, ...
    expected.mcapex.per_rack_monitoring, expected.mcapex.network_infrastructure]);

expected.mcapex.heat_pump_capex_rate_gbp_per_kwth = inputs.heat_pump_capex_rate;
expected.mcapex.heat_pump_unit = ifzero(expected.mc.heat_pump_enabled == 1, ...
    expected.mc.heat_pump_capacity_kwth * expected.mcapex.heat_pump_capex_rate_gbp_per_kwth);
expected.mcapex.heat_pump_installation = ifzero(expected.mc.heat_pump_enabled == 1, ...
    expected.mcapex.heat_pump_unit * 0.15);
expected.mcapex.heat_pump_controls = ifzero(expected.mc.heat_pump_enabled == 1, 15000);
expected.mcapex.subtotal_heat_pump = sum([expected.mcapex.heat_pump_unit, ...
    expected.mcapex.heat_pump_installation, expected.mcapex.heat_pump_controls]);

expected.mcapex.premium_rate_pct = rp.capex_premium_vs_air_cooled_pct / 100;
expected.mcapex.applied_to_base_infrastructure = (expected.mcapex.subtotal_enclosure ...
    + expected.mcapex.subtotal_dtc_cooling + expected.mcapex.subtotal_immersion_cooling) ...
    * expected.mcapex.premium_rate_pct;
expected.mcapex.base_infrastructure = expected.mcapex.subtotal_enclosure ...
    + expected.mcapex.subtotal_dtc_cooling + expected.mcapex.subtotal_immersion_cooling ...
    + expected.mcapex.subtotal_power + expected.mcapex.subtotal_thermal ...
    + expected.mcapex.subtotal_monitoring;
expected.mcapex.cooling_premium = expected.mcapex.applied_to_base_infrastructure;
expected.mcapex.heat_pump = expected.mcapex.subtotal_heat_pump;
expected.mcapex.total_module_capex = expected.mcapex.base_infrastructure ...
    + expected.mcapex.cooling_premium + expected.mcapex.heat_pump;
expected.mcapex.capex_per_it_kw_gbp_per_kw = expected.mcapex.total_module_capex ...
    / expected.mcapex.module_it_capacity_kw;
expected.mcapex.capex_per_gpu_gbp_per_gpu = expected.mcapex.total_module_capex / rp.gpus_per_module;

expected.mopex = struct();
expected.mopex.electricity_rate_gbp_per_kwh = inputs.electricity_rate;
expected.mopex.infrastructure_power_from_pue = rp.pue_contribution - 1;
expected.mopex.infrastructure_power_cost_gbp_per_yr = expected.mc.module_it_capacity_kw ...
    * expected.mopex.infrastructure_power_from_pue * expected.mc.hours_per_year ...
    * expected.mopex.electricity_rate_gbp_per_kwh * expected.mc.target_utilisation_rate_pct;

if expected.mc.heat_pump_enabled == 1
    expected.mopex.heat_pump_electricity_gbp_per_yr = (expected.mc.thermal_output_kwth ...
        / expected.mc.heat_pump_cop) * expected.mc.hours_per_year ...
        * expected.mc.target_utilisation_rate_pct * expected.mopex.electricity_rate_gbp_per_kwh;
else
    expected.mopex.heat_pump_electricity_gbp_per_yr = 0;
end

expected.mopex.subtotal_electricity = expected.mopex.infrastructure_power_cost_gbp_per_yr ...
    + expected.mopex.heat_pump_electricity_gbp_per_yr;

expected.mopex.base_maintenance_pct_of_base_capex = inputs.base_maintenance_pct;
expected.mopex.base_maintenance_gbp_per_yr = expected.mcapex.base_infrastructure ...
    * expected.mopex.base_maintenance_pct_of_base_capex;

expected.mopex.heat_pump_maintenance_pct_of_hp_capex = inputs.heat_pump_maintenance_pct;
if expected.mc.heat_pump_enabled == 1
    expected.mopex.heat_pump_maintenance_gbp_per_yr = expected.mcapex.heat_pump_unit ...
        * expected.mopex.heat_pump_maintenance_pct_of_hp_capex;
else
    expected.mopex.heat_pump_maintenance_gbp_per_yr = 0;
end

expected.mopex.insurance_pct_of_total_capex = inputs.insurance_pct;
expected.mopex.insurance_gbp_per_yr = expected.mcapex.total_module_capex ...
    * expected.mopex.insurance_pct_of_total_capex;

expected.mopex.subtotal_maintenance_insurance = expected.mopex.base_maintenance_gbp_per_yr ...
    + expected.mopex.heat_pump_maintenance_gbp_per_yr + expected.mopex.insurance_gbp_per_yr;

expected.mopex.site_lease_per_licence_gbp_per_yr = inputs.site_lease;
expected.mopex.remote_monitoring_noc_gbp_per_yr = inputs.remote_monitoring;
expected.mopex.connectivity_admin_gbp_per_yr = inputs.connectivity_admin;
expected.mopex.subtotal_other = sum([expected.mopex.site_lease_per_licence_gbp_per_yr, ...
    expected.mopex.remote_monitoring_noc_gbp_per_yr, expected.mopex.connectivity_admin_gbp_per_yr]);

expected.mopex.total_module_opex_gbp_per_yr = expected.mopex.subtotal_electricity ...
    + expected.mopex.subtotal_maintenance_insurance + expected.mopex.subtotal_other;

expected.mflow = struct();
expected.mflow.specific_heat_of_water_kj_per_kg_k = inputs.specific_heat;
expected.mflow.water_density_kg_per_l = inputs.water_density;
expected.mflow.thermal_power_kwth = expected.mc.captured_heat_kwth;
expected.mflow.inlet_temperature_c = expected.mc.capture_temperature_c;
expected.mflow.source_loop_deltat_c = lookupSourceDeltaT(expected.mcapex.cooling_method, ref);
expected.mflow.outlet_temperature_c = expected.mflow.inlet_temperature_c - expected.mflow.source_loop_deltat_c;

expected.mflow.mass_flow_rate_kg_per_s = expected.mflow.thermal_power_kwth ...
    / (expected.mflow.specific_heat_of_water_kj_per_kg_k * expected.mflow.source_loop_deltat_c);
expected.mflow.volume_flow_rate_l_per_s = expected.mflow.mass_flow_rate_kg_per_s ...
    / expected.mflow.water_density_kg_per_l;
expected.mflow.volume_flow_rate_m3_per_hr = expected.mflow.volume_flow_rate_l_per_s * 3.6;

expected.mflow.thermal_power_delivered_kwth = expected.mc.thermal_output_kwth;
expected.mflow.outlet_temperature_c__b20 = expected.mc.delivery_temperature_c;
expected.mflow.sink_loop_deltat_c = inputs.sink_loop_deltat;
expected.mflow.return_temperature_c = expected.mflow.outlet_temperature_c__b20 ...
    - expected.mflow.sink_loop_deltat_c;

expected.mflow.mass_flow_rate_kg_per_s__b24 = expected.mflow.thermal_power_delivered_kwth ...
    / (expected.mflow.specific_heat_of_water_kj_per_kg_k * expected.mflow.sink_loop_deltat_c);
expected.mflow.volume_flow_rate_l_per_s__b25 = expected.mflow.mass_flow_rate_kg_per_s__b24 ...
    / expected.mflow.water_density_kg_per_l;
expected.mflow.volume_flow_rate_m3_per_hr__b26 = expected.mflow.volume_flow_rate_l_per_s__b25 * 3.6;

expected.mflow.design_velocity_m_per_s = inputs.design_velocity;
expected.mflow.source_loop_pipe_id_mm = sqrt((expected.mflow.volume_flow_rate_l_per_s / 1000) ...
    / (expected.mflow.design_velocity_m_per_s * 3.14159 / 4)) * 1000;
expected.mflow.sink_loop_pipe_id_mm = sqrt((expected.mflow.volume_flow_rate_l_per_s__b25 / 1000) ...
    / (expected.mflow.design_velocity_m_per_s * 3.14159 / 4)) * 1000;

expected.mflow.source_loop_nearest_dn = nearestDN(expected.mflow.source_loop_pipe_id_mm);
expected.mflow.sink_loop_nearest_dn = nearestDN(expected.mflow.sink_loop_pipe_id_mm);

expected.mflow.thermal_capacity_kwth = expected.mflow.thermal_power_delivered_kwth;
expected.mflow.delivery_temperature_c = expected.mflow.outlet_temperature_c__b20;
expected.mflow.flow_capacity_m3_per_hr = expected.mflow.volume_flow_rate_m3_per_hr__b26;
end

function [expected, has_excel_values] = readExcelExpectedModuleCriteria(excel_path)
data = readExcelRange(excel_path, '1. Module Criteria', 'B5:B30');
get_cell = @(row) data{row - 5 + 1, 1};

sentinel_rows = [11, 17, 21, 24];
has_excel_values = hasValues(get_cell, sentinel_rows);

mapping = { ...
    'module_it_capacity_kw', 5, 1; ...
    'compute_rate_gbp_per_kw_per_month', 6, 1; ...
    'target_utilisation_rate_pct', 7, 1; ...
    'heat_capture_rate_pct', 10, 1; ...
    'captured_heat_kwth', 11, 1; ...
    'capture_temperature_c', 12, 1; ...
    'heat_pump_enabled', 15, 1; ...
    'heat_pump_output_temperature_c', 16, 1; ...
    'heat_pump_cop', 17, 1; ...
    'heat_pump_capacity_kwth', 18, 1; ...
    'thermal_output_kwth', 21, 1; ...
    'delivery_temperature_c', 22, 1; ...
    'hours_per_year', 23, 1; ...
    'annual_heat_output_mwh', 24, 1; ...
    'base_heat_price_no_hp_gbp_per_mwh', 27, 1; ...
    'premium_heat_price_with_hp_gbp_per_mwh', 28, 1; ...
    'effective_heat_price_gbp_per_mwh', 29, 1; ...
    'reference_industrial_gas_price_gbp_per_mwh', 30, 1 ...
    };

expected = readMappedCells(data, 5, mapping);
end

function [expected, has_excel_values] = readExcelExpectedModuleCapex(excel_path)
data = readExcelRange(excel_path, '2. Module Capex', 'B5:C69');
get_cell = @(row) data{row - 5 + 1, 1};

sentinel_rows = [16, 56, 66];
has_excel_values = hasValues(get_cell, sentinel_rows);

mapping = { ...
    'chipset', 5, 1; ...
    'cooling_method', 6, 1; ...
    'racks_per_module', 7, 1; ...
    'servers_per_module', 8, 1; ...
    'module_it_capacity_kw', 9, 1; ...
    'captured_heat_kwth', 10, 1; ...
    'container_shell', 13, 1; ...
    'container_fit_out', 14, 1; ...
    'rack_enclosures', 15, 1; ...
    'rack_enclosures__fixed_per_module', 15, 2; ...
    'subtotal_enclosure', 16, 1; ...
    'cold_plate_kits', 19, 1; ...
    'cdu_base', 20, 1; ...
    'cdu_capacity_scaling', 21, 1; ...
    'manifolds_quick_connects', 22, 1; ...
    'primary_loop_piping', 23, 1; ...
    'subtotal_dtc_cooling', 24, 1; ...
    'immersion_tanks', 27, 1; ...
    'dielectric_fluid_initial_fill', 28, 1; ...
    'fluid_management_system', 29, 1; ...
    'subtotal_immersion_cooling', 30, 1; ...
    'rack_pdus', 33, 1; ...
    'module_power_distribution', 34, 1; ...
    'electrical_panels_switchgear', 35, 1; ...
    'subtotal_power', 36, 1; ...
    'primary_heat_exchanger_base', 39, 1; ...
    'heat_exchanger_capacity_scaling', 40, 1; ...
    'thermal_integration_skid', 41, 1; ...
    'instrumentation_sensors', 42, 1; ...
    'subtotal_thermal', 43, 1; ...
    'bms_base_system', 46, 1; ...
    'per_rack_monitoring', 47, 1; ...
    'network_infrastructure', 48, 1; ...
    'subtotal_monitoring', 49, 1; ...
    'heat_pump_capex_rate_gbp_per_kwth', 52, 1; ...
    'heat_pump_unit', 53, 1; ...
    'heat_pump_installation', 54, 1; ...
    'heat_pump_controls', 55, 1; ...
    'subtotal_heat_pump', 56, 1; ...
    'premium_rate_pct', 59, 1; ...
    'applied_to_base_infrastructure', 60, 1; ...
    'base_infrastructure', 63, 1; ...
    'cooling_premium', 64, 1; ...
    'heat_pump', 65, 1; ...
    'total_module_capex', 66, 1; ...
    'capex_per_it_kw_gbp_per_kw', 68, 1; ...
    'capex_per_gpu_gbp_per_gpu', 69, 1 ...
    };

expected = readMappedCells(data, 5, mapping);
end

function [expected, has_excel_values] = readExcelExpectedModuleOpex(excel_path)
data = readExcelRange(excel_path, '3. Module Opex', 'B5:B29');
get_cell = @(row) data{row - 5 + 1, 1};

sentinel_rows = [7, 10, 21, 29];
has_excel_values = hasValues(get_cell, sentinel_rows);

mapping = { ...
    'electricity_rate_gbp_per_kwh', 5, 1; ...
    'infrastructure_power_from_pue', 6, 1; ...
    'infrastructure_power_cost_gbp_per_yr', 7, 1; ...
    'heat_pump_electricity_gbp_per_yr', 9, 1; ...
    'subtotal_electricity', 10, 1; ...
    'base_maintenance_pct_of_base_capex', 15, 1; ...
    'base_maintenance_gbp_per_yr', 16, 1; ...
    'heat_pump_maintenance_pct_of_hp_capex', 17, 1; ...
    'heat_pump_maintenance_gbp_per_yr', 18, 1; ...
    'insurance_pct_of_total_capex', 19, 1; ...
    'insurance_gbp_per_yr', 20, 1; ...
    'subtotal_maintenance_insurance', 21, 1; ...
    'site_lease_per_licence_gbp_per_yr', 24, 1; ...
    'remote_monitoring_noc_gbp_per_yr', 25, 1; ...
    'connectivity_admin_gbp_per_yr', 26, 1; ...
    'subtotal_other', 27, 1; ...
    'total_module_opex_gbp_per_yr', 29, 1 ...
    };

expected = readMappedCells(data, 5, mapping);
end

function [expected, has_excel_values] = readExcelExpectedModuleFlow(excel_path)
data = readExcelRange(excel_path, '4. Module Flow', 'B5:B39');
get_cell = @(row) data{row - 5 + 1, 1};

sentinel_rows = [14, 16, 30, 39];
has_excel_values = hasValues(get_cell, sentinel_rows);

mapping = { ...
    'specific_heat_of_water_kj_per_kg_k', 5, 1; ...
    'water_density_kg_per_l', 6, 1; ...
    'thermal_power_kwth', 9, 1; ...
    'inlet_temperature_c', 10, 1; ...
    'source_loop_deltat_c', 11, 1; ...
    'outlet_temperature_c', 12, 1; ...
    'mass_flow_rate_kg_per_s', 14, 1; ...
    'volume_flow_rate_l_per_s', 15, 1; ...
    'volume_flow_rate_m3_per_hr', 16, 1; ...
    'thermal_power_delivered_kwth', 19, 1; ...
    'outlet_temperature_c__b20', 20, 1; ...
    'sink_loop_deltat_c', 21, 1; ...
    'return_temperature_c', 22, 1; ...
    'mass_flow_rate_kg_per_s__b24', 24, 1; ...
    'volume_flow_rate_l_per_s__b25', 25, 1; ...
    'volume_flow_rate_m3_per_hr__b26', 26, 1; ...
    'design_velocity_m_per_s', 29, 1; ...
    'source_loop_pipe_id_mm', 30, 1; ...
    'sink_loop_pipe_id_mm', 31, 1; ...
    'source_loop_nearest_dn', 33, 1; ...
    'sink_loop_nearest_dn', 34, 1; ...
    'thermal_capacity_kwth', 37, 1; ...
    'delivery_temperature_c', 38, 1; ...
    'flow_capacity_m3_per_hr', 39, 1 ...
    };

expected = readMappedCells(data, 5, mapping);
end

function ok = runHeatPumpToggleTests(all_pass, inputs, rp, ref, mc_fields, mcapex_fields, mopex_fields, mflow_fields)
inputs_off = inputs;
inputs_off.hp_enabled = 0;

mc = tribe.calc.calcModuleCriteria(rp, inputs_off.hp_enabled, inputs_off.hp_output_temp, ...
    inputs_off.utilisation, inputs_off.hours_per_year, inputs_off.base_heat_price, inputs_off.premium_heat_price);
mcapex = tribe.calc.calcModuleCapex(rp, mc, ref);
mopex = tribe.calc.calcModuleOpex(rp, mc, mcapex, inputs_off.electricity_rate);
mflow = tribe.calc.calcModuleFlow(mc, rp.cooling_method, ref);

expected = calcExpected(rp, inputs_off, ref);

for i = 1:numel(mc_fields)
    field = mc_fields(i);
    all_pass = checkEqual("hp_off.mc." + field, mc.(field), expected.mc.(field)) && all_pass;
end

for i = 1:numel(mcapex_fields)
    field = mcapex_fields(i);
    all_pass = checkEqual("hp_off.mcapex." + field, mcapex.(field), expected.mcapex.(field)) && all_pass;
end

for i = 1:numel(mopex_fields)
    field = mopex_fields(i);
    all_pass = checkEqual("hp_off.mopex." + field, mopex.(field), expected.mopex.(field)) && all_pass;
end

for i = 1:numel(mflow_fields)
    field = mflow_fields(i);
    all_pass = checkEqual("hp_off.mflow." + field, mflow.(field), expected.mflow.(field)) && all_pass;
end

ok = all_pass;
end

function expected = readMappedCells(data, start_row, mapping)
expected = struct();
for i = 1:size(mapping, 1)
    field = mapping{i, 1};
    row = mapping{i, 2};
    col = mapping{i, 3};
    value = data{row - start_row + 1, col};
    if isFormulaValue(value) || ismissingValue(value)
        continue;
    end
    expected.(field) = value;
end
end

function tf = hasValues(get_cell, rows)
tf = false;
for i = 1:numel(rows)
    value = get_cell(rows(i));
    if isFormulaValue(value) || ismissingValue(value)
        continue;
    end
    if isnumeric(value)
        if any(~isnan(value), 'all') && any(abs(value) > 0, 'all')
            tf = true;
            return;
        end
    elseif (isstring(value) || ischar(value)) && strlength(string(value)) > 0
        tf = true;
        return;
    end
end
end

function ok = checkEqual(label, expected, actual)
if isstring(expected) || ischar(expected)
    ok = isequal(string(expected), string(actual));
elseif isnumeric(expected)
    ok = isnumeric(actual) && isequal(size(expected), size(actual)) ...
        && all(abs(expected - actual) < 1e-9, 'all');
else
    ok = isequaln(expected, actual);
end

if ok
    fprintf('PASS: %s\n', label);
else
    fprintf('FAIL: %s | expected: %s | actual: %s\n', label, valueToString(expected), valueToString(actual));
end
end

function data = readExcelRange(excel_path, sheet, range)
try
    data = readcell(excel_path, 'Sheet', sheet, 'Range', range, 'UseExcel', true);
catch
    data = readcell(excel_path, 'Sheet', sheet, 'Range', range);
end
end

function tf = isFormulaValue(value)
tf = (ischar(value) || isstring(value)) && startsWith(string(value), "=");
end

function tf = ismissingValue(value)
tf = isempty(value) ...
    || (isstring(value) && all(ismissing(value))) ...
    || (isnumeric(value) && any(isnan(value), 'all'));
end

function cop = boundCop(cop_raw, ref)
cop = max(ref.minimum_practical_cop, min(ref.maximum_practical_cop, cop_raw));
end

function delta_t = lookupSourceDeltaT(cooling_method, ref)
switch string(cooling_method)
    case "Direct-to-Chip (DTC)"
        delta_t = ref.direct_to_chip_dtc__source_deltat_c;
    case "Single-Phase Immersion"
        delta_t = ref.single_phase_immersion__source_deltat_c;
    case "Two-Phase Immersion"
        delta_t = ref.two_phase_immersion__source_deltat_c;
    case "Rear Door Heat Exchanger"
        delta_t = ref.rear_door_heat_exchanger__source_deltat_c;
    otherwise
        delta_t = ref.air_cooled_reference__source_deltat_c;
end
end

function dn = nearestDN(pipe_id_mm)
if pipe_id_mm < 28
    dn = "DN25";
elseif pipe_id_mm < 36
    dn = "DN32";
elseif pipe_id_mm < 42
    dn = "DN40";
elseif pipe_id_mm < 54
    dn = "DN50";
elseif pipe_id_mm < 68
    dn = "DN65";
elseif pipe_id_mm < 82
    dn = "DN80";
elseif pipe_id_mm < 107
    dn = "DN100";
else
    dn = "DN125+";
end
end

function value = ifzero(condition, result)
if condition
    value = result;
else
    value = 0;
end
end

function text = valueToString(value)
if isstring(value) || ischar(value)
    text = char(string(value));
elseif isnumeric(value)
    text = mat2str(value);
else
    text = '<unprintable>';
end
end

function expected = mergeExpected(expected, excel_expected)
fields = fieldnames(excel_expected);
for i = 1:numel(fields)
    field = fields{i};
    expected.(field) = excel_expected.(field);
end
end
